#!/bin/sh

set -o errexit
set -o nounset


readonly EXIT_SUCCESS=0

PROGRAM="$(basename "$0")"
readonly PROGRAM

readonly NOTES_DIR_BASE="${HOME}/.t"

NOTES_DIR="${NOTES_DIR_BASE}"
if [ -n "${N+x}" ]; then
    NOTES_DIR="${NOTES_DIR}/${N}"
fi

readonly NOTES_DIR


cmd_help() {
    echo "USAGE
    T script for fast notes

    t                - Show notes in format '[INDEX] NOTE NAME (LINES)'
    t show           - Show notes in format '[INDEX] NOTE NAME (LINES)'
    t add [X X X]    - Add note with name X X X
    t edit (INDEX)   - Edit note with INDEX by \$EDITOR
    t delete (INDEX) - Delete note with INDEX
    t namespaces     - Show namespaces
    t help           - Show this message

    t a  - alias to add
    t e  - alias to edit
    t d  - alias to delete
    t ns - alias to namespaces


NAMESPACES
    N=work t a fix bug 211  # add note in workspace 'work'
    N=work t  # show notes in workspace 'work'
"
}


die() {
    echo "${PROGRAM}: Error: ${1}" 1>&2
    exit "${2:-$EXIT_SUCCESS}"
}

show_notes_with_indexes() {
    SAVEIFS="${IFS}"
    IFS='
'
    index=1
    for note in $(find "${NOTES_DIR}" -maxdepth 1 -type f | sort -n)
    do
        note_lines="$(wc -l < "${note}")"
        printf "[%d] %s (%s)\n" "${index}" "$(basename "${note}")" "${note_lines}"
        index="$((index+1))"
    done

    IFS="${SAVEIFS}"
}

_remove_first_and_last_element() {
    cut -d" " -f2- | rev | cut -d" " -f2- | rev
}

find_note_name_by_index() {
    note_index="${1}"
    show_notes_with_indexes | grep "^\[${note_index}\]" | _remove_first_and_last_element
}

cmd_add_note() {
    note="${NOTES_DIR}/$*"
    touch "${note}"
    exit "$EXIT_SUCCESS"
}

cmd_delete_note() {
    note_index="${1}"
    note="$(find_note_name_by_index "${note_index}")"
    note_to_remove="${NOTES_DIR}/${note}"

    if [ ! -f "${note_to_remove}" ]; then
        die "Note with index ${note_index} not found" 1
    fi

    rm "${note_to_remove}"
    exit "$EXIT_SUCCESS"
}

cmd_edit_note() {
    note_index="${1}"
    note="$(find_note_name_by_index "${note_index}")"
    note_to_edit="${NOTES_DIR}/${note}"

    if [ ! -f "${note_to_edit}" ]; then
        die "Note with index ${note_index} not found" 1
    fi

    $EDITOR "${note_to_edit}"
    exit "$EXIT_SUCCESS"
}

cmd_cat_note() {
    note_index="${1}"
    note="$(find_note_name_by_index "${note_index}")"
    note_to_cat="${NOTES_DIR}/${note}"

    if [ ! -f "${note_to_cat}" ]; then
        die "Note with index ${note_index} not found" 1
    fi

    cat "${note_to_cat}"
    exit "$EXIT_SUCCESS"
}

cmd_show_namespaces() {
    find "${NOTES_DIR_BASE}/" -mindepth 1 -type d -exec basename {} \;
}

remove_empty_namespaces() {
    find "${NOTES_DIR_BASE}" -type d -empty -exec rm -r {} \; 2>/dev/null || true
}

trap remove_empty_namespaces EXIT


if [ ! -d "${NOTES_DIR}" ]; then
    mkdir -p "${NOTES_DIR}"
fi


if [ -z "${1+x}" ]; then
    show_notes_with_indexes
    exit "$EXIT_SUCCESS"
fi


case "$1" in
    show) shift;           show_notes_with_indexes ;;
    ns|namespaces) shift;  cmd_show_namespaces     ;;
    add|a) shift;          cmd_add_note       "$@" ;;
    delete|d) shift;       cmd_delete_note    "$@" ;;
    e|edit) shift;         cmd_edit_note      "$@" ;;
    help) shift;           cmd_help          "$@" ;;

    *)                cmd_cat_note "$@" ;;
esac
exit "$EXIT_SUCCESS"